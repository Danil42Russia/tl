// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package gen_tlo

type TlsType struct {
	Name            int32
	Id              string
	ConstructorsNum int32
	Flags           int32
	Arity           int32
	ParamsType      int64
}

func (TlsType) TLName() string { return "tls.type" }
func (TlsType) TLTag() uint32  { return 0x12eb4386 }

func (item *TlsType) Reset() {
	item.Name = 0
	item.Id = ""
	item.ConstructorsNum = 0
	item.Flags = 0
	item.Arity = 0
	item.ParamsType = 0
}

func (item *TlsType) Read(w []byte) (_ []byte, err error) {
	if w, err = IntRead(w, &item.Name); err != nil {
		return w, err
	}
	if w, err = StringRead(w, &item.Id); err != nil {
		return w, err
	}
	if w, err = IntRead(w, &item.ConstructorsNum); err != nil {
		return w, err
	}
	if w, err = IntRead(w, &item.Flags); err != nil {
		return w, err
	}
	if w, err = IntRead(w, &item.Arity); err != nil {
		return w, err
	}
	return LongRead(w, &item.ParamsType)
}

func (item *TlsType) Write(w []byte) (_ []byte, err error) {
	w = IntWrite(w, item.Name)
	if w, err = StringWrite(w, item.Id); err != nil {
		return w, err
	}
	w = IntWrite(w, item.ConstructorsNum)
	w = IntWrite(w, item.Flags)
	w = IntWrite(w, item.Arity)
	return LongWrite(w, item.ParamsType), nil
}

func (item *TlsType) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = NatReadExactTag(w, 0x12eb4386); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TlsType) WriteBoxed(w []byte) ([]byte, error) {
	w = NatWrite(w, 0x12eb4386)
	return item.Write(w)
}

func (item TlsType) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func TlsType__ReadJSON(item *TlsType, j interface{}) error { return item.readJSON(j) }
func (item *TlsType) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("tls.type", "expected json object")
	}
	_jName := _jm["name"]
	delete(_jm, "name")
	if err := JsonReadInt32(_jName, &item.Name); err != nil {
		return err
	}
	_jId := _jm["id"]
	delete(_jm, "id")
	if err := JsonReadString(_jId, &item.Id); err != nil {
		return err
	}
	_jConstructorsNum := _jm["constructors_num"]
	delete(_jm, "constructors_num")
	if err := JsonReadInt32(_jConstructorsNum, &item.ConstructorsNum); err != nil {
		return err
	}
	_jFlags := _jm["flags"]
	delete(_jm, "flags")
	if err := JsonReadInt32(_jFlags, &item.Flags); err != nil {
		return err
	}
	_jArity := _jm["arity"]
	delete(_jm, "arity")
	if err := JsonReadInt32(_jArity, &item.Arity); err != nil {
		return err
	}
	_jParamsType := _jm["params_type"]
	delete(_jm, "params_type")
	if err := JsonReadInt64(_jParamsType, &item.ParamsType); err != nil {
		return err
	}
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.type", k)
	}
	return nil
}

func (item *TlsType) WriteJSON(w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.Name != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"name":`...)
		w = JSONWriteInt32(w, item.Name)
	}
	if len(item.Id) != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"id":`...)
		w = JSONWriteString(w, item.Id)
	}
	if item.ConstructorsNum != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"constructors_num":`...)
		w = JSONWriteInt32(w, item.ConstructorsNum)
	}
	if item.Flags != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"flags":`...)
		w = JSONWriteInt32(w, item.Flags)
	}
	if item.Arity != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"arity":`...)
		w = JSONWriteInt32(w, item.Arity)
	}
	if item.ParamsType != 0 {
		w = JSONAddCommaIfNeeded(w)
		w = append(w, `"params_type":`...)
		w = JSONWriteInt64(w, item.ParamsType)
	}
	return append(w, '}'), nil
}

func (item *TlsType) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *TlsType) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("tls.type", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("tls.type", err.Error())
	}
	return nil
}

func TupleTlsTypeBoxedRead(w []byte, vec *[]TlsType, nat_n uint32) (_ []byte, err error) {
	if err = CheckLengthSanity(w, nat_n, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < nat_n {
		*vec = make([]TlsType, nat_n)
	} else {
		*vec = (*vec)[:nat_n]
	}
	for i := range *vec {
		if w, err = (*vec)[i].ReadBoxed(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func TupleTlsTypeBoxedWrite(w []byte, vec []TlsType, nat_n uint32) (_ []byte, err error) {
	if uint32(len(vec)) != nat_n {
		return w, ErrorWrongSequenceLength("[]TlsType", len(vec), nat_n)
	}
	for _, elem := range vec {
		if w, err = elem.WriteBoxed(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func TupleTlsTypeBoxedReadJSON(j interface{}, vec *[]TlsType, nat_n uint32) error {
	_, _arr, err := JsonReadArrayFixedSize("[]TlsType", j, nat_n)
	if err != nil {
		return err
	}
	if uint32(cap(*vec)) < nat_n {
		*vec = make([]TlsType, nat_n)
	} else {
		*vec = (*vec)[:nat_n]
	}
	for i := range *vec {
		if err := TlsType__ReadJSON(&(*vec)[i], _arr[i]); err != nil {
			return err
		}
	}
	return nil
}

func TupleTlsTypeBoxedWriteJSON(w []byte, vec []TlsType, nat_n uint32) (_ []byte, err error) {
	if uint32(len(vec)) != nat_n {
		return w, ErrorWrongSequenceLength("[]TlsType", len(vec), nat_n)
	}
	w = append(w, '[')
	for _, elem := range vec {
		w = JSONAddCommaIfNeeded(w)
		if w, err = elem.WriteJSON(w); err != nil {
			return w, err
		}
	}
	return append(w, ']'), nil
}
